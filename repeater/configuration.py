from argparse import ArgumentParser
from matplotlib import colormaps
from os.path import exists
from pathlib import Path

from led.src.baseclasses import Configuration as __BaseConfiguration__

class Configuration(__BaseConfiguration__):
	'''
	This class defines a configuration object for modeling a scrolling window displaying a signal read from a JSON-formatted list for a string of programmagle LED lights
	It builds upon and extends the superclass configuration object
	'''

	signal_file = None
	scaling_factor = None
	logarithmic = None
	length = None
	direction = None
	origin_point = None
	colormap_name = None
	colormap = None

	def __init__(self, **kwargs):
		'''
		**kwargs : dict
			A set of named incoming parameters
		'''

		# First, call the superclass's initialization with the incoming named argument dict
		super(Configuration, self).__init__(**kwargs)

		if (self.configured):
			# The superclass's initialization did not produce any errors, re-set configured to False and begin looking for incoming parameters specific to this class
			self.configured = False

			# Iterate over a set (one element now) of required named arguments and handle them
			# Overkill with just one element, but it lays a good precedent and can grow as needed
			required_kwargs = [
				{
					"name": "default_colormap",
					"attribute": "colormap_name",
					"type": str,
				},
			]

			for kwarg in required_kwargs:
				if (kwarg["name"] not in kwargs):
					self.errors.append(f"Configuration object requires named argument {kwarg['name']} of type {kwarg['type'].__name__}")
				elif (kwargs[kwarg["name"]] == None):
					self.errors.append(f"The {kwarg['name']} named argument must be of type {kwarg['type'].__name__}, not None")
				elif (type(kwargs[kwarg["name"]]) != kwarg["type"]):
					self.errors.append(f"The {kwarg['name']} named argument must be of type {kwarg['type'].__name__}, not of type {type(kwargs[kwarg['name']]).__name__}")
				elif ((kwarg['type'] == str) and (kwargs[kwarg["name"]] == "") and (("can_be_empty" not in kwarg) or (not bool(kwarg["can_be_empty"])))):
					self.errors.append(f"The {kwarg['name']} named argument must be a non-empty string")
				else:
					# This named argument is syntactically valid, save it as an object parameter
					setattr(self, kwarg["attribute"], kwargs[kwarg["name"]])

			if (len(self.errors) == 0):
				# No errors have been generated so far, now add the additional project-speciic command-line arguments to check for and then parse the incoming argument set

				self.argument_parser.add_argument("-s", "--signal", "--message", type=str, required=True, help="JSON-formatted list file that contains the signal to be replayed")
				self.argument_parser.add_argument("-f", "--factor", "--scalingfactor", "--scaling-factor", type=float, help="Amount by which the signal being replayed will be scaled")
				self.argument_parser.add_argument("-g", "--log", "--logarithmic", action="store_true", help="Flag indicating that the signal being replayed should be coverted to a common logarithm")
				self.argument_parser.add_argument("-l", "--length", type=int, required=True, help="Scrolling window length in pixels (int)")
				self.argument_parser.add_argument("-d", "--direction", type=str, help='The direction the window scrolls in, valid values are "left", "right" and "both" (str)')
				self.argument_parser.add_argument("-o", "--input_origin", "--inputorigin", type=float, help="For windows that scroll in both directions, the point in the window where the incoming value is placed (int)")
				self.argument_parser.add_argument("-m", "--map", type=str, help="matplotlib Colormap to be applied to the signals generated by this project run (string)")

				# The parser arguments for this configuration object have been set up, now parse the command line and check for the base set of expected/available
				# arguments as defined by the superclass
				arguments = super(Configuration, self).check_parsed_arguments()

				self.logarithmic = arguments.log

				if (arguments.signal == ""):
					self.errors.append("-s (--signal/--message) argument cannot be an empty string")
				else:
					signal_file = arguments.signal if ((arguments.signal.find("/") + arguments.signal.find("\\")) >= 0) else f"{arguments.projectfolder}/{arguments.signal}"
					if (not exists(signal_file)):
						self.errors.append(f"-s (--signal/--message) argument {signal_file} is not a valid file path")
					else:
						self.signal_file = Path(signal_file)
						if (not self.signal_file.is_file()):
							self.errors.append(f"-s (--signal/--message) argument {signal_file} is not a valid file path")

				# Accept scaling_factor argument as is, it was accepted as a floating-point value or is None -- both options are valid
				self.scaling_factor = arguments.factor

				if (arguments.length <= 0):
					self.errors.append(f"-l (--length) argument must be a positive integer, not {arguments.length}")
				else:
					self.length = arguments.length

				# Accept direction and input_point arguments as-is, they have been determined to be string and numeric respectively and will both be validated
				# by the LEDModel that tries to use them
				self.direction = arguments.direction
				self.input_origin = arguments.input_origin

				if ((arguments.map != None) and (arguments.map != "")):
					self.colormap_name = arguments.map

				# Attempt to load the desired colormap from the matplotlib library
				try:
					self.colormap = colormaps[self.colormap_name]
				except Exception as e:
					self.errors.append(f"-m (--map) color map argument {self.colormap_name} was not found in matplotlib")

		# All configuration work has been done, check for errors and dipslay any that occurred
		self.configured = len(self.errors) == 0
		if (not self.configured):
			print(f"ERROR - This signal repeater project could not be configured.  The following error{'s' if (len(self.errors) != 1) else ''} occurred:")
			print("\n".join(self.errors))
