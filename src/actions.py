import cv2
import json
import numpy as np

from matplotlib import colors, pyplot as plt
from matplotlib.axes._subplots import Axes, Subplot
from matplotlib.figure import Figure
from matplotlib.lines import Line2D
from PIL import Image
from typing import List

import led.src.baseclasses

def run_model(model:led.src.baseclasses.LEDModel, source:any, samples_to_run:int, figure:Figure=None, line_frame:Line2D=None, time_series:List[any]=None, frames:np.ndarray=None):
	'''
	This function runs a set of samples a feeds the output from one or more signal sources into a model and records the results for return to the calling object

	Parameters
	----------
	model : subclass of led.src.baseclasses.LEDModel
		The model object which is being run by this method call
	source : any
		The set of signal sources that will be fed into this model; it can either be an individual object that is a subclass of led.src.baseclasses.SignalGenerator or a list of such objects
	samples_to_run : int
		The number of samples to be processed by this method call, must be zero or greater
	figure : matplotlib.figure.Figure
		A Figure object used for graphing the response of this model to the inputs during this method call
		If it and the companion argument line_frame argument are both valid objects, the graph is generated
	line_frame : matplotlib.lines.Line2D
		A Line2D object used for graphing the response of this model to the inputs during this method call
		If it and the companion argument figure argument are both valid objects, the graph is generated
	time_series : List[any]
		A list of previous model run results, the type of list element is dependent upon the model's frame
		If time_series is a valid list object, the values generated by this model run will be appended to it
	frames : numpy.ndarray
		A numpy array of previous model run frames
		If frames is a valid numpy array, the frames generated by this model run will be appended to it

	Returns
	-------
	List[any]
		The set of value generated by this run of the model; if a time_series list was passed in as an argument, the results from this run are appended to the incoming time_series
	numpy.ndarray
		The numpy array set of full data frames generated by the run of this model; if a frames array was passed in as an argument, the results from this run are appended to the incoming frames
	'''

	# Validate all incoming arguments, raising Exceptions if they are not valid

	if (model == None):
		raise Exception("model argument must be a subclass of led.src.baseclasses.LEDModel")
	elif (not issubclass(type(model), led.src.baseclasses.LEDModel)):
		raise Exception(f"model argument must be a subclass of led.src.baseclasses.LEDModel, {type(model).__name__} is not")

	if (source == None):
		raise Exception("source argument must be either a signal source or a list of sources that are subclasses of led.src.baseclasses.SignalGenerator")
	else:
		source_type = type(source)
		if (source_type == list):
			for i in source:
				if (i is None):
					raise Exception(f"None element found in source argument")
				elif (not issubclass(type(i), led.src.baseclasses.SignalGenerator)):
					raise Exception(f"all elements in source argument must be subclasses of led.src.baseclasses.SignalGenerator, {type(i).__name__} is not")
		elif (not issubclass(source_type, led.src.baseclasses.SignalGenerator)):
			raise Exception(f"source argument must be either a signal source or a list of sources that are subclasses of led.src.baseclasses.SignalGenerator, {source_type.__name__} is not")

	if (samples_to_run == None):
		# samples_to_run is None, meaning that this method should run until the generator object returns an end_of_signal value of True
		# RIGHT NOW, THIS ONLY WORKS WITH ONE SOURCE, A FUTURE UPGRADE WILL ALLOW IT TO HANDLE MULITPLE SOURCES

		if (not hasattr(source, "end_of_signal")):
			raise Exception(f"source argument of type {type(source).__name__} does not have an end_of_signal attribute")
		else:
			samples_to_run = None
	else:
		# samples_to_run is not None, check it -- an invalid samples_to_run is not fatal, zero will be used instead
		if ((samples_to_run == None) or (type(samples_to_run) not in [int, float]) or (samples_to_run < 0)):
			samples_to_run = 0
		else:
			samples_to_run = int(samples_to_run)

	if ((figure != None) and (type(figure) != Figure)):
		raise Exception(f"if present, figure argument must be of type matplotlib.figure.Figure, not {type(figure).__name__}")

	if ((line_frame != None) and (type(line_frame) != Line2D)):
		raise Exception(f"if present, line_frame argument must be of type matplotlib.lines.Line2D, not {type(line_frame).__name__}")

	if ((time_series != None) and (type(time_series) != list)):
		raise Exception(f"if present, time_series argument must be a list, not an object of type {type(time_series).__name__}")

	if ((type(frames) != np.ndarray) and (frames != None)):
		raise Exception(f"if present, frames argument must be a numpy array, not an object of type {type(frames).__name__}")

	# If the method call has made it to this point, all incoming arguments are at least syntactically valid, now run the model with the sources

	# Set a Boolean flag so we don't have to run this check every iteration
	display_graph = (figure != None) and (line_frame != None)

	if (time_series == None):
		# time_series is empty, initialize it to an empty list
		time_series = []

	if (type(frames) != np.ndarray):
		# frames is empty, initialize it to an empt numpy array one dimension larger than the model's frame shape
		# Initialize an empty or invalid incoming frames object into an empty numpy array
		frames = np.empty((0, *model.frame.shape))

	# All the set-up is done, now iterate over the number of samples and run this model
	if (samples_to_run == None):
		while (not source.end_of_signal):
			model.input(source.next)
			time_series.append(model.frame[0])
			frames = np.append(frames, [model.frame], axis=0)

			if (display_graph):
				line_frame.set_ydata(model.frame)
				figure.canvas.draw()
				figure.canvas.flush_events()
	else:
		# This method call should run for a specific number of samples, iterate over that range and and run the samples

		for i in range(samples_to_run):
			# Add the values together from every source
			value = 0
			if (type(source) != list):
				value = source.next
			elif (len(source) > 0):
				value = sum([i.next for i in source])

			model.input(value)
			time_series.append(model.frame[0])
			frames = np.append(frames, [model.frame], axis=0)

			if (display_graph):
				line_frame.set_ydata(model.frame)
				figure.canvas.draw()
				figure.canvas.flush_events()

	return (time_series, frames)


def color_time_series(time_series:List[any], colormap:any, figure:Figure, axis:any):
	'''
	This function takes a list of data and graphs it using the specified colormap

	Parameters
	----------
	time_series : List[any]
		A list of previous model run results, the type of list element is dependent upon the model's frame
	colormap : any
		The colormap that will be applied to the time_series argument, it must be of a class in the matplotlib.colors
	figure : matplotlib.figure.Figure
		A Figure object used for graphing the time_series data
	axis : any
		An axis object used for graphing the time_series data
	'''

	# Validate all incoming arguments, raising Exceptions if they are not valid

	if (time_series == None):
		raise Exception("time_series argument must be a non-empty list")
	elif (type(time_series) != list):
		raise Exception(f"time_series argument must be a non-empty list, not an object of type {type(time_series).__name__}")
	elif (len(time_series) == 0):
		raise Exception("time_series argument must be a non-empty list, is it an empty list")

	if (colormap == None):
		raise Exception("colormap must be a color in the matplotlib.colors module")
	elif (colormap.__class__.__module__ != colors.__name__):
		raise Exception(f"colormap must be a color in the matplotlib.colors module, not an object of type {type(colormap).__name__}")

	if (figure == None):
		raise Exception("figure argument must be a matplotlib.figure.Figure object")
	elif (type(figure) != Figure):
		raise Exception(f"figure argument must be a matplotlib.figure.Figure object, not an object of type {type(figure).__name__}")

	if (axis == None):
		raise Exception("axis argument must be a maplotlib axes object")
	else:
		axis_type = type(axis)
		if ((not issubclass(axis_type, Axes)) or (not issubclass(axis_type, Subplot))):
			raise Exception(f"axis argument must be a matplitlib axes object, not an object of type {axis_type.__name__}")

	# If the method call has made it to this point, all incoming arguments are at least syntactically valid, now run the model with the sources

	# Shift display_values up so that no values in it are negative, and then normalize the list (i.e. scale it between zero and one)
	min_value = min(time_series)
	display_series = [value - min_value for value in time_series]

	max_value = max(display_series)
	if (max_value != 0):
		display_series = [value / max_value for value in display_series]

	# Set the labels for the x-axis, set the height of the window and display the colorized time_series data as a bar graph with each bar's color matching its height
	x_labels = list(range(len(display_series)))
	axis.set_ylim((min(display_series) - 0.1), (max(display_series) + 0.1))
	axis.bar(x_labels, display_series, color=colormap(display_series))

	plt.show(block=True)


def save_time_series(time_series:List[any], filename:str):
	'''
	This function takes a list of data and saves it out as a JSON-formatted text file

	Parameters
	----------
	time_series : List[any]
		A list of previous model run results, the type of list element is dependent upon the model's frame
	filename : str
		The path/name of the file to which time_series will be written
	'''

	# Validate all incoming arguments, raising Exceptions if they are not valid

	if (time_series == None):
		raise Exception("time_series argument must be a list")
	elif (type(time_series) != list):
		raise Exception(f"time_series argument must be a list, not an object of type {type(time_series).__name__}")

	if (filename == None):
		raise Exception("filename argument must be a non-empty string")
	elif (type(filename) != str):
		raise Exception(f"filename argument must be a non-empty string, not an object of type {type(time_series).__name__}")
	elif (filename == ""):
		raise Exception("filename argument must be a non-empty string, it is currently empty")

	# If the method call has made it to this point, all incoming arguments are at least syntactically valid, now save time_series

	with open(filename, "w") as file_out:
		json.dump(time_series, file_out)


def colorize_frames(frames:np.ndarray, colormap:any, frame_shape:tuple):
	'''
	This function takes in a set of data frames and applies color to its values according to the accompanying colormap
	Because this application uses two different libraries, one to generate an image and one to generate a video
	The image creation library wants the color data in Red - Green - Blue (RGB) order
	The video creation library wants the color dat in Blue - Red - Green (BRG) order
		USING THIS COLORIZED SET OF FRAMES TO CREATE THE VIDEO FILE WILL PRODUCT A COLOR-DISTORTED VIDEO, BUT WHEN THE MOVIE IS USED BY
		THE LEDEDIT SOFTWARE TO GENERATE THE LET LIGHT PROGRAM, THE GREEN AND RED CHANNELS ARE SWITCHED, SO THE COLORS WILL BE CORRECT IN THE LED STRING

	Parameters
	----------
	frame : numpy.ndarray
		A set of frames from the model run that will have the colormap applied to them
	colormap : any
		The colormap that will be applied to the time_series argument, it must be of a class in the matplotlib.colors
	frame_shape : tuple
		The shape of a single data frame stored in the model

	Returns
	-------
	numpy.ndarray
		The frames argument with the colormap applied, with each value converted to a set of RGB integers ranging between 0 and 255
		This is done because the pillow library that creates an image from these frames wants the values to be in RGB format
	numpy.ndarray
		The frames argument with the colormap applied, with each value converted to a set of BRG (Blue-Red-Green) integers ranging between 0 and 255
	'''

	# Validate all incoming arguments, raising Exceptions if they are not valid

	return_rgb = None
	return_brg = None

	if (type(frames) != np.ndarray):
		# Confirming that an object is a numpy array is a little different with checking for None
		if (frames == None):
			raise Exception("frames argument must be a numpy array")
		else:
			raise Exception(f"frames argument must be a numpy array, not an object of type {type(frames).__name__}")

	if (colormap == None):
		raise Exception("colormap argument must be a color in the matplotlib.colors module")
	elif (colormap.__class__.__module__ != colors.__name__):
		raise Exception(f"colormap must be a color in the matplotlib.colors module, not an object of type {type(colormap).__name__}")

	if (frame_shape == None):
		raise Exception("frame_shape argument must be a non-empty tuple of integers")
	elif (type(frame_shape) != tuple):
		raise Exception(f"frame_shape argument must be a non-empty tuple of integers, not an object of type {type(frame_shape).__name__}")
	elif (len(frame_shape) == 0):
		raise Exception("frame_shape argument is an empty tuple, it cannot be empty")

	# If the method call has made it to this point, all incoming arguments are at least syntactically valid, now save time_series

	# Attempt to normalize the values in frames to make them all between zero and one
	minimum = np.min(frames)
	maximum = np.max(frames)
	if (minimum != maximum):
		# frames contains something other than the same value in every position, normalize it
		frames = (frames - minimum) / (maximum - minimum)
	else:
		# frames only contains the same value in every position, flatten the whole thing to an array of ones
		frames = np.ones(frames.shape)

	# Initialize the color-mapped version of the data frames by applying a color map to the first frame, removing its alpha value (the A in RGBA)
	# and converting the remaining RGB values from floats between 0 and 1 to integers between 0 and 255
	# Then iterate over the rest of frames, perform the same color mapping and conversion on each one and append the result to mapped_frames
	return_rgb = np.empty((0, *frame_shape, 4))
	for i in range(0, frames.shape[0]):
		return_rgb = np.append(return_rgb, [colormap(frames[i])], axis=0)

	return_rgb = np.array(255 * np.delete(return_rgb, 3, 2)).astype(np.uint8)

	# Convert the RGB-formatted version of the frames to BRG-formatted (Blue-Red-Green) by rotating right the individual pixel's RGB values
	#return_brg = np.flip(return_rgb, axis=(len(return_rgb.shape) - 1))
	return_brg = np.roll(return_rgb, 1, axis=(len(return_rgb.shape) - 1))

	return (return_rgb, return_brg)


def save_frames_image(frames:np.ndarray, filename:str):
	'''
	This function takes a set of data frames and saves it as an image that serves as a "temporal" contact sheet showing every frame in one image

	Parameters
	----------
	frames : numpy.ndarray
		A set of frames from the model run that will be rendered as an image
	filename : str
		The path/name of the file to which frames will be written as an image

	Returns
	-------
	PIL.Image
		Python image library (pillow, PIL) Image object that was created by the incoming data frames
	'''

	return_image = None

	# Validate all incoming arguments, raising Exceptions if they are not valid

	if (type(frames) != np.ndarray):
		# Confirming that an object is a numpy array is a little different with checking for None
		if (frames == None):
			raise Exception("frames argument must be a numpy array")
		else:
			raise Exception(f"frames argument must be a numpy array, not an object of type {type(frames).__name__}")

	if (filename == None):
		raise Exception("filename argument must be a non-empty string")
	elif (type(filename) != str):
		raise Exception(f"filename argument must be a non-empty string, not an object of type {type(time_series).__name__}")
	elif (filename == ""):
		raise Exception("filename argument must be a non-empty string, it is currently empty")

	# If the method call has made it to this point, all incoming arguments are at least syntactically valid, now save time_series

	return_image = Image.fromarray(frames)
	return_image.save(filename)

	return return_image


# Define a set of defaults used by the next function
default_codec = "mp4v"
default_frames_per_second = 30

def save_frames_video(frames:np.ndarray, filename:str, frame_shape:tuple, codec:str=default_codec, frames_per_second:int=default_frames_per_second):
	'''
	This function dates in a set of data frames and attempts to save create a video from them and save it to a file

	Parameters
	----------
	frames : np.ndarray
		The set of data frames that will be converted to a video, they are assumed to already be colorized and in BRG format
	filename : str
		The name of the file to which this video will be saved
	frame_shape : tuple
		The shape of a single frame of video
		Through trial and error, it has been determined that OpenCV (cv2) cannot create a video that is only one pixel tall, thus if the frames
		argument is only one pixel tall, it will be added to the video twice
	codec : str
		The identifier in OpenCV (cv2) of the CODEC that will generate the frames of video and join them to the final video object; defaults to a pre-determined value
	frames_per_second : int
		The speed of the video that will be generated with each frame of data corresponding to a frame of video; defaults to a pre-determined value
	'''

	# Validate all incoming arguments, raising Exceptions if they are not valid

	if (type(frames) != np.ndarray):
		# Confirming that an object is a numpy array is a little different with checking for None
		if (frames == None):
			raise Exception("frames argument must be a numpy array")
		else:
			raise Exception(f"frames argument must be a numpy array, not an object of type {type(frames).__name__}")

	if (filename == None):
		raise Exception("filename argument must be a non-empty string")
	elif (type(filename) != str):
		raise Exception(f"filename argument must be a non-empty string, not an object of type {type(time_series).__name__}")
	elif (filename == ""):
		raise Exception("filename argument must be a non-empty string, it is currently empty")

	if (frame_shape == None):
		raise Exception("frame_shape argument must be a tuple of two positive integers and the second one must be two or greater")
	elif (type(frame_shape) != tuple):
		raise Exception(f"frame_shape argument must be a tuple of two positive integers, not an object of type {type(time_series).__name__}")
	elif (len(frame_shape) != 2):
		raise Exception(f"frame_shape argument must be a tuple of two positive integers, not an tuple of length {len(frame_shape)}")
	elif (
		(type(frame_shape[0]) not in [int, float]) or (frame_shape[0] < 1)
		or (type(frame_shape[1]) not in [int, float]) or (frame_shape[1] < 2)
	):
		raise Exception("frame_shape argument must be a tuple of two positive integers and the second one must be two or greater")
	else:
		# The values in frame_shape are numeric, now make sure they are integers
		frame_shape = (int(frame_shape[0]), int(frame_shape[1]))

	if (codec == None):
		codec = default_codec
	elif (type(codec) != str):
		raise Exception(f"if precent, codec argument must be a non-empty string, not an object of type {type(codec).__name__}")
	elif (codec == ""):
		raise Exception("if present, codec argument must be a non-empty string")

	if (frames_per_second == None):
		frames_per_second = default_frames_per_second
	elif (type(frames_per_second) not in [int, float]):
		raise Exception(f"if present, frames_per_second argument must be a positive integer between 1 and 60, not an object of type {type(frames_per_second).__name__}")
	else:
		frames_per_second = int(frames_per_second)
		if ((frames_per_second < 1) or (frames_per_second > 60)):
			raise Exception(f"if present, frames_per_second argument must be a positive integer between 1 and 60, not {frames_per_second}")

	# If the method call has made it to this point, all incoming arguments are at least syntactically valid, now save time_series

	# For data frames that are only one pixel wide (i.e. three BRG color elements), the data frame must be added the video obect twice
	add_twice = True if ((len(frames.shape) > 2) and (frames.shape[-3] > 0) and (frames[0].shape[1] == 3)) else False

	out_video = cv2.VideoWriter(filename, cv2.VideoWriter_fourcc(*codec), frames_per_second, frame_shape)
	for i in range(frames.shape[0]):
		out_video.write(np.array([frames[i], frames[i]]) if (add_twice) else frames[i])

	out_video.release()
