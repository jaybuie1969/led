from argparse import ArgumentParser, Namespace

class Configuration:
	'''
	THIS CLASS IS NOT INTENDED TO BE INSTANTIATED DIRECTLY
	This class definition is intended to be used as a parent class for a particular LED project's configuration
	This class defines the minimal configuration object for a run of a script within this application
	It takes in a set of defaults and defines an initial set of command-line arguments for parsing
	'''

	time_series_file = None
	image_file = None
	video_file = None

	argument_parser = ArgumentParser()
	configured = False
	errors = []

	def __init__(self, **kwargs):
		'''
		As this initialiation method executes, it attempts to set an expected group object-level parameters
		Any error messages accumulated during this initialization
		IN THE CHILD CLASS, THIS METHOD SHOULD BE OVER-RIDDEN AND THEN EXPLICITLY CALLED BEFORE DOING ANYTHING ELSE

		**kwargs : dict
			A set of named incoming parameters
		'''

		required_kwargs = [
			{
				"name": "default_time_series_file",
				"attribute": "time_series_file",
				"type": str,
			},
			{
				"name": "default_image_file",
				"attribute": "image_file",
				"type": str,
			},
			{
				"name": "default_video_file",
				"attribute": "video_file",
				"type": str,
			},
		]

		for kwarg in required_kwargs:
			if (kwarg["name"] not in kwargs):
				self.errors.append(f"Configuration object requires named argument {kwarg['name']} of type {kwarg['type'].__name__}")
			elif (kwargs[kwarg["name"]] == None):
				self.errors.append(f"The {kwarg['name']} named argument must be of type {kwarg['type'].__name__}, not None")
			elif (type(kwargs[kwarg["name"]]) != kwarg["type"]):
				self.errors.append(f"The {kwarg['name']} named argument must be of type {kwarg['type'].__name__}, not of type {type(kwargs[kwarg['name']]).__name__}")
			elif ((kwarg['type'] == str) and (kwargs[kwarg["name"]] == "") and (("can_be_empty" not in kwarg) or (not bool(kwarg["can_be_empty"])))):
				self.errors.append(f"The {kwarg['name']} named argument must be a non-empty string")
			else:
				# This named argument is syntactically valid, save it as an object parameter
				setattr(self, kwarg["attribute"], kwargs[kwarg["name"]])

		if (len(self.errors) == 0):
			# No errors have been generated so far, now build a set of arguments to check for in the command-line parameters submitted with this project run
			# NOTE: This does not parse any arguments yet, that is left up to the child class to do after they have added their own set of arguments to check
			self.argument_parser.add_argument("projectfolder", type=str, help="folder in which this project is located, by default, files generated by this script run are saved in this folder by default")
			self.argument_parser.add_argument("-t", "--time_series", "--time-series", "--timeseries", type=str, help=f"Optional destination file name for generated time-series data (replaces {self.time_series_file})")
			self.argument_parser.add_argument("-i", "--image", type=str, help=f"Optional destination file name for generated image (replaces {self.image_file})")
			self.argument_parser.add_argument("-v", "--video", type=str, help=f"Optional destination file name for generated video (replaces {self.video_file})")

		# If there are no error messages, this base confiuration ojbect is configured successfully
		self.configured = len(self.errors) == 0

	def check_parsed_arguments(self):
		'''
		This method handles looking for the base set of command-line parameters permitted or required by this base configuration object
		IN THE CHILD CLASS, THIS METHOD SHOULD BE CALLED AS SOON AS self.argument_parser IS FULLY SET UP

		Returns:
		--------
		argparser.Namespace
			The set of command-line arguments retrieved by the argument parser
		'''

		arguments = self.argument_parser.parse_args()
		if (type(arguments) == Namespace):
			# For each of these destination filename arguments, check to see if each one includes a directory path or is just a bare file name
			# If it includes a directory path, copy it across as-is; if it is a bare file name, prepend the projectfolder argument to it

			if (arguments.time_series != None):
				self.time_series_file = arguments.time_series if ((arguments.time_series.find("/") + arguments.time_series.find("\\")) >= 0) else f"{arguments.projectfolder}/{arguments.time_series}"
			elif ((self.time_series_file.find("/") + self.time_series_file.find("\\")) < 0):
				self.time_series_file = f"{arguments.projectfolder}/{self.time_series_file}"

			if (arguments.image != None):
				self.image_file = arguments.image if ((arguments.image.find("/") + arguments.image.find("\\")) >= 0) else f"{arguments.projectfolder}/{arguments.image}"
			elif ((self.image_file.find("/") + self.image_file.find("\\")) < 0):
				self.image_file = f"{arguments.projectfolder}/{self.image_file}"

			if (arguments.video != None):
				self.video_file = arguments.video if ((arguments.video.find("/") + arguments.video.find("\\")) >= 0) else f"{arguments.projectfolder}/{arguments.video}"
			elif ((self.video_file.find("/") + self.video_file.find("\\")) < 0):
				self.video_file = f"{arguments.projectfolder}/{self.video_file}"

		return arguments


class LEDModel:
	'''
	THIS CLASS IS NOT INTENDED TO BE INSTANTIATED DIRECTLY
	This class definition is intended to be used as a parent class for LED models built for this application
	This class defines a minimal obect to compute, store and return the current state of the model
	The intention is that the model's state can be reflected as both an instaneous point in a time series of data and as a full data
	frame that includes the state of every LED in the model
	'''

	# This attribute will hold the name of the attribute that will be aliased as the computed property "frame"
	frame_attribute = None

	@property
	def frame(self):
		'''
		This computed property is an alias for whatever property in the child subclass is intended to hold the current state of this model
		'''
		print("In property self.frame")
		return getattr(self, self.frame_attribute) if (self.frame_attribute != None) else None


class SignalGenerator:
	'''
	THIS CLASS IS NOT INTENDED TO BE INSTANTIATED DIRECTLY
	This class definition is intended to be used as a parent class for signal generators built for this application
	This class defines a minimal obect to handle retrieving the current value to be emitted by this generator and for computing the next value
	The intention is that the child class will handle the specific logic for computing the next value
	'''

	counter = 0
	current_value = None

	def compute_next_value(self):
		'''
		THIS METHOD IS NOT INTENDED TO BE USED AS IS -- IT IS INTENDED TO BE OVERWRITTEN BY THE CHILD CLASS
		This method is included here as a place-holding interface
		The child class's version should incorporate the logic needed by this particular model to compute the next value to be emited by this generator
		'''

		# In the child class's version, the logic would go here and be used to set self.current_value
		# self.current_value = <<RESULT OF SOME GENERATOR LOGIC>>
		pass


	@property
	def current(self):
		'''
		This computed property is the current value of this sine wave generator
		If this object has not been started with a next() method call, it will return a None

		Returns
		-------
		any
			The current value of this generator object, the exact type will depend on the generator
		'''
		return self.current_value

	@property
	def next(self):
		'''
		This computed property is the next value of this sine wave and saves the new value into the object's parameters

		Returns
		-------
		any
			The current value of this generator object, the exact type will depend on the generator
		'''

		'''
		# Use the object's current sample counter to compute the next sine value
		self.current_value = self.amplitude * sin((2.0 * pi * self.counter / self.wavelength) + self.phase)

		# Increment counter for the next next() call
		self.counter = self.counter + 1

		return self.current_value
		'''

		self.compute_next_value()

		# Increment counter for the next compute_next_value() call
		self.counter = self.counter + 1

		return self.current_value

	def input(self, value:any):
		'''
		THIS METHOD IS NOT INTENDED TO BE USED AS IS -- IT IS INTENDED TO BE OVERWRITTEN BY THE CHILD CLASS
		This method is included here as a place-holding interface
		The child class's version should incorporate the logic needed by this particular model to handle the signal value(s) coming in from the source signal generator(s)

		Parameters
		----------
		value : any
			The value that is coming into this model, the particulars about type and any processing will be handled by the child class's implementation of this method
		'''

		# In the child class's version, the logic would go here and be used to set self.current_value
		# self.current_value = <<RESULT OF SOME GENERATOR LOGIC>>
		pass
