from argparse import ArgumentParser
from matplotlib import colormaps
from os.path import exists
from pathlib import Path

from led.src.baseclasses import Configuration as __BaseConfiguration__

class Configuration(__BaseConfiguration__):
	'''
	This class defines a configuration object for modeling a scrolling window displaying a set of instantaneous signal values from a group of signal generators
	The immediate intent is to have a group of simulated alarm level data streams each implemented as single-value color gauges displaying the immediate alarm
	status of each signal set
	'''

	length = None
	gauges = None
	signal_file = None
	scaling_factors = None
	colormap_name = None
	colormap = None

	def __init__(self, **kwargs):
		'''
		**kwargs : dict
			A set of named incoming parameters
		'''

		# First, call the superclass's initialization with the incoming named argument dict
		super(Configuration, self).__init__(**kwargs)

		if (self.configured):
			# The superclass's initialization did not produce any errors, re-set configured to False and begin looking for incoming parameters specific to this class
			self.configured = False

			# Iterate over a set (one element now) of required named arguments and handle them
			# Overkill with just one element, but it lays a good precedent and can grow as needed
			required_kwargs = [
				{
					"name": "default_colormap",
					"attribute": "colormap_name",
					"type": str,
				},
			]

			for kwarg in required_kwargs:
				if (kwarg["name"] not in kwargs):
					self.errors.append(f"Configuration object requires named argument {kwarg['name']} of type {kwarg['type'].__name__}")
				elif (kwargs[kwarg["name"]] == None):
					self.errors.append(f"The {kwarg['name']} named argument must be of type {kwarg['type'].__name__}, not None")
				elif (type(kwargs[kwarg["name"]]) != kwarg["type"]):
					self.errors.append(f"The {kwarg['name']} named argument must be of type {kwarg['type'].__name__}, not of type {type(kwargs[kwarg['name']]).__name__}")
				elif ((kwarg['type'] == str) and (kwargs[kwarg["name"]] == "") and (("can_be_empty" not in kwarg) or (not bool(kwarg["can_be_empty"])))):
					self.errors.append(f"The {kwarg['name']} named argument must be a non-empty string")
				else:
					# This named argument is syntactically valid, save it as an object parameter
					setattr(self, kwarg["attribute"], kwargs[kwarg["name"]])

			if (len(self.errors) == 0):
				# No errors have been generated so far, now add the additional project-speciic command-line arguments to check for and then parse the incoming argument set

				self.argument_parser.add_argument("-l", "--length", type=int, required=True, help="Gauge set window length in pixels (int)")
				self.argument_parser.add_argument("-s", "--signalset", "--messageset", type=str, required=True, help="JSON-formatted object file that contains a set of signals to be replayed and their desired configuration")
				self.argument_parser.add_argument("-f", "--factors", "--scalingfactors", "--scaling-factors", type=str, help="Amount by which the signals being replayed will be scaled (string of comma-separated floats)")
				self.argument_parser.add_argument("-m", "--map", type=str, help="matplotlib Colormap to be applied to the signal set generated by this project run (string)")

				# The parser arguments for this configuration object have been set up, now parse the command line and check for the base set of expected/available
				# arguments as defined by the superclass
				arguments = super(Configuration, self).check_parsed_arguments()

				if (arguments.length <= 0):
					self.errors.append(f"-l (--length) argument must be a positive integer, not {arguments.length}")
				else:
					self.length = arguments.length

				if (arguments.signalset == ""):
					self.errors.append("-s (--signalset/--messageset) argument must be a valid file name")
				else:
					# The signalset argument was not empty make sure it is a valid file
					signal_file = arguments.signalset if ((arguments.signalset.find("/") + arguments.signalset.find("\\")) >= 0) else f"{arguments.projectfolder}/{arguments.signalset}"
					if (not exists(signal_file)):
						self.errors.append(f"-s (--signalset/--messageset) argument {signal_file} is not a valid file path")
					else:
						self.signal_file = Path(signal_file)
						if (not self.signal_file.is_file()):
							self.errors.append(f"-s (--signalset/--messageset) argument {signal_file} is not a valid file path")

				if ((arguments.factors == None) or (arguments.factors == "")):
					# Without any scaling factor attributes, just use an empty list
					self.scaling_factors = []
				else:
					# Attempt to parse arguments.factors into a list of floating-point numbers
					for i in arguments.factors.split(","):
						try:
							self.scaling_factors.append(float(i))
						except:
							self.errors.append(f"value {i} in -f (--factors/--scalingfactors/--scaling-factors) argument is not a number")

				if ((arguments.map != None) and (arguments.map != "")):
					self.colormap_name = arguments.map

				# Attempt to load the desired colormap from the matplotlib library
				try:
					self.colormap = colormaps[self.colormap_name]
				except Exception as e:
					self.errors.append(f"-m (--map) color map argument {self.colormap_name} was not found in matplotlib")

		# All configuration work has been done, check for errors and dipslay any that occurred
		self.configured = len(self.errors) == 0
		if (not self.configured):
			print(f"ERROR - This signal repeater project could not be configured.  The following error{'s' if (len(self.errors) != 1) else ''} occurred:")
			print("\n".join(self.errors))
