from argparse import ArgumentParser
from  matplotlib import colormaps

from led.src.baseclasses import Configuration as __BaseConfiguration__

class Configuration(__BaseConfiguration__):
	'''
	This class defines a configuration object for modeling a quarter-wave single-pole antenna for a string of programmagle LED lights
	It builds upon and extends the superclass configuration object
	'''

	length = None
	wavelength = None
	amplitude = None
	phase = None
	colormap_name = None
	colormap = None

	def __init__(self, **kwargs):
		'''
		**kwargs : dict
			A set of named incoming parameters
		'''

		# First, call the superclass's initialization with the incoming named argument dict
		super(Configuration, self).__init__(**kwargs)

		if (self.configured):
			# The superclass's initialization did not produce any errors, re-set configured to False and begin looking for incoming parameters specific to this class
			self.configured = False

			# Iterate over a set (one element now) of required named arguments and handle them
			# Overkill with just one element, but it lays a good precedent and can grow as needed
			required_kwargs = [
				{
					"name": "default_colormap",
					"attribute": "colormap_name",
					"type": str,
				},
			]

			for kwarg in required_kwargs:
				if (kwarg["name"] not in kwargs):
					self.errors.append(f"Configuration object requires named argument {kwarg['name']} of type {kwarg['type'].__name__}")
				elif (kwargs[kwarg["name"]] == None):
					self.errors.append(f"The {kwarg['name']} named argument must be of type {kwarg['type'].__name__}, not None")
				elif (type(kwargs[kwarg["name"]]) != kwarg["type"]):
					self.errors.append(f"The {kwarg['name']} named argument must be of type {kwarg['type'].__name__}, not of type {type(kwargs[kwarg['name']]).__name__}")
				elif ((kwarg['type'] == str) and (kwargs[kwarg["name"]] == "") and (("can_be_empty" not in kwarg) or (not bool(kwarg["can_be_empty"])))):
					self.errors.append(f"The {kwarg['name']} named argument must be a non-empty string")
				else:
					# This named argument is syntactically valid, save it as an object parameter
					setattr(self, kwarg["attribute"], kwargs[kwarg["name"]])

			if (len(self.errors) == 0):
				# No errors have been generated so far, now add the additional command-line arguments to check for and then parse the incoming argument set

				self.argument_parser.add_argument("-l", "--length", type=int, required=True, help="Antenna length in pixels (int)")
				self.argument_parser.add_argument("-w", "--wavelength", "--wavelen", type=float, help="Fundamental sample wavelength for the signals used by this project run (float, allows for aperiodoc series)")
				self.argument_parser.add_argument("-a", "--amplitude", "--amp", type=float, help="Fundamental amplitude for signals used by this project run (float)")
				self.argument_parser.add_argument("-p", "--phase", type=float, help="Fundamental phase shift for signals used by this project run (float)")
				self.argument_parser.add_argument("-m", "--map", type=str, help="matplotlib Colormap to be applied to the signals generated by this project run (string)")

				# The parser arguments for this configuration object have been set up, now parse the command line and check for the base set of expected/available
				# arguments as defined by the superclass
				arguments = super(Configuration, self).check_parsed_arguments()

				if (arguments.length <= 0):
					self.errors.append(f"The -l (--length) argument must be a positive integer, not {arguments.length}")
				else:
					self.length = arguments.length

				if (arguments.wavelength != None):
					if (arguments.wavelength < 1):
						self.errors.append(f"The -w (--wavelength) argument must be 1 or greater, not {arguments.wavelength}")
					else:
						self.wavelength = arguments.wavelength

				# Accept amplitude and phase arguments as-is, they have been determined to be of type float, we aren't worried about anything else with them
				self.amplitude = arguments.amplitude
				self.phase = arguments.phase

				if ((arguments.map != None) and (arguments.map != "")):
					self.colormap_name = arguments.map

				# Attempt to load the desired colormap from the matplotlib library
				try:
					self.colormap = colormaps[self.colormap_name]
				except Exception as e:
					self.errors.append(f"color map name {self.colormap_name} was not found in matplotlib")

		# All configuration work has been done, check for errors and dipslay any that occurred
		self.configured = len(self.errors) == 0
		if (not self.configured):
			print(f"ERROR - This LED project could not be configured.  The following error{'s' if (len(self.errors) != 1) else ''} occurred:")
			print("\n".join(self.errors))
